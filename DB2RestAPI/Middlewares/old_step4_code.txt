using Azure;
using Azure.Core;
using Com.H.Data;
using DB2RestAPI.Settings;
using DB2RestAPI.Settings.Extensinos;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Configuration;
using System.Security.Cryptography;
using System.Text;
using System.Text.Json;

namespace DB2RestAPI.Middlewares
{
    /// <summary>
    /// Fourth middleware in the pipeline that processes API gateway routing requests.
    /// 
    /// This middleware acts as a reverse proxy, forwarding requests to external APIs when the
    /// service type is 'api_gateway'. For other service types (e.g., 'db_query'), it passes 
    /// the request to the next middleware without modification.
    /// 
    /// Required context.Items from previous middlewares:
    /// - `route`: String representing the matched route path
    /// - `section`: IConfigurationSection for the route's configuration
    /// - `service_type`: String indicating service type (must be `api_gateway` for processing)
    /// - `remaining_path`: Additional path segments to append to target URL (for wildcard routes)
    /// 
    /// API Gateway functionality:
    /// - Constructs target URL from route configuration
    /// - Forwards HTTP method, headers, query strings, and request body
    /// - Supports header exclusion and override (per-route or default)
    /// - Handles SSL certificate validation settings
    /// - Streams response back to the caller with appropriate headers
    /// 
    /// Configuration options per route:
    /// - `url`: Target API endpoint (required)
    /// - `excluded_headers`: Headers to exclude when forwarding
    /// - `applied_headers`: Headers to add/override in forwarded request
    /// - `ignore_target_route_certificate_errors`: Allow self-signed/invalid certificates
    /// 
    /// Responses:
    /// - Proxied response: Returns the exact response from the target API
    /// - 500 Internal Server Error: Missing configuration or improper setup
    /// - Passes to next middleware: Service type is not 'api_gateway'
    /// </summary>

    public class Step4APIGatewayProcess(
        RequestDelegate next,
        IConfiguration configuration,
        SettingsService settings,
        IHttpClientFactory httpClientFactory,
        ILogger<Step4APIGatewayProcess> logger
            )
    {
        private readonly RequestDelegate _next = next;
        private readonly SettingsService _settings = settings;
        private readonly IConfiguration _configuration = configuration;
        private readonly IHttpClientFactory httpClientFactory = httpClientFactory;
        private readonly ILogger<Step4APIGatewayProcess> _logger = logger;
        /// <summary>
        /// Headers that should not be copied from the target response to the client response.
        /// These headers are managed by ASP.NET Core and manually setting them could cause issues.
        /// </summary>
        private static readonly string[] excludedResponseHeaders = new string[] { "Transfer-Encoding", "Content-Length" };
        private static readonly string _errorCode = "Step 4 - Gateway Process Error";

        public async Task InvokeAsync(HttpContext context)
        {

            #region log the time and the middleware name
            this._logger.LogDebug("{time}: in Step4APIGatewayProcess middleware",
                DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fffff"));
            #endregion


            #region if no section passed from the previous middlewares, return 500
            IConfigurationSection? section = context.Items.ContainsKey("section")
                ? context.Items["section"] as IConfigurationSection
                : null;

            if (section == null)
            {

                await context.Response.DeferredWriteAsJsonAsync(
                    new ObjectResult(
                        new
                        {
                            success = false,
                            // SMWSE6: standard middleware section error
                            message = $"Improper service setup. (Contact your service provider support and provide them with error code `{_errorCode}`)"
                        }
                    )
                    {
                        StatusCode = 500
                    }
                );

                return;
            }
            #endregion

            #region if no service type passed from the previous middlewares, return 500


            //var containsServiceType = context.Items.ContainsKey("service_type")
            //    && context.Items["serivce_type"] is string serviceType
            //    && !string.IsNullOrWhiteSpace(serviceType);

            //this._logger.LogDebug("Contains service type: {containsServiceType}",
            //    containsServiceType);

            if (!context.Items.ContainsKey("service_type"))
            {
                await context.Response.DeferredWriteAsJsonAsync(
                    new ObjectResult(
                        new
                        {
                            success = false,
                            // SMWSTE6: standard middleware service type error 6
                            message = $"Improper service setup. (Contact your service provider support and provide them with error code `{_errorCode}`)"
                        }
                    )
                    {
                        StatusCode = 500
                    }
                );
                return;
            }
            #endregion

            #region if service type is not `api_gateway`, call the next middleware
            if (context.Items["service_type"] as string != "api_gateway")
            {
                await _next(context);
                return;
            }

            #endregion

            #region url check
            var url = section.GetValue<string>("url");

            if (string.IsNullOrWhiteSpace(url))
            {

                await context.Response.DeferredWriteAsJsonAsync(
                    new ObjectResult(
                        new
                        {
                            success = false,
                            message = $"Improper route settings (missing `url`). (Contact your service provider support and provide them with error code `{_errorCode}`)"
                        }
                    )
                    {
                        StatusCode = 500
                    }
                );
                return;
            }

            #endregion

            #region get parameters
            // retrieve the parameters (which consists of query string parameters and headers)
            var qParams = this._settings.GetParams(section, context);

            #endregion

            #region check if there are any mandatory parameters missing
            var failedMandatoryCheckResponse = this._settings
                .GetFailedMandatoryParamsCheckIfAny(section, qParams);
            if (failedMandatoryCheckResponse != null)
            {
                await context.Response.DeferredWriteAsJsonAsync(failedMandatoryCheckResponse);
                return;
            }
            #endregion



            #region get remaining path and apply it to the url
            var remainingPath = context.Items["remaining_path"] as string;
            if (!string.IsNullOrWhiteSpace(remainingPath))
            {
                // url might have a query string, 
                // so we need to insert the remaining path
                // before the query string or append it to the url
                // if there is no query string.
                if (!url.Contains('?'))
                    url += remainingPath;
                else
                    // insert the remaining path before the query string `?`
                    url = url.Insert(url.IndexOf('?'), remainingPath);
            }
            #endregion

            #region get caller's query string

            // check if `this.Request` has query string
            // if queryString has values, append it to the url, and if the url already has a query string, append it with `&`
            if (!string.IsNullOrWhiteSpace(context.Request.QueryString.Value))
            {
                url += string.Concat(url.Contains('?') ? "&" : "?", context.Request.QueryString.Value.AsSpan(1));
                // the above is equivalent to:
                // url += (url.Contains("?") ? "&" : "?") + context.Request.QueryString.Value.Substring(1);
            }

            #endregion


            /* todo: cache implementation should be here
             1- first you need to refactor (starting from prepare target request msg region onward) into a separate method
                let's call the method `ProcessApiGatewayRequest`

             2- then just like in ApiController.cs, have something like this:
                var response = await _settings.CacheService
                    .Get<ObjectResult>(
                    section, 
                    qParams,
                    disableStreaming => ProcessApiGatewayRequest(section, qParams, disableStreaming),
                    HttpContext.RequestAborted
                    );
               but unlike ApiController.cs, the `ProcessApiGatewayRequest` method should stream 
               the response directly to the HttpContext.Response.BodyWriter if `disableStreaming` is false
               and return a null ObjectResult as it will have already written the response directly to the response body.
               and if `disableStreaming` is true, it should read all the response into memory and return it as an ObjectResult.
             3- then after the above call, check if response is not null, and if so, write it to the context.Response
                with your DeferredWriteAsJsonAsync extension method.

            */



            // route the current request (with headers and action to url)
            #region prepare target request msg
            var targetRequestMsg = new HttpRequestMessage(new HttpMethod(context.Request.Method), url);

            // see if the request has a body
            if (context.Request.Body?.CanRead == true)
                targetRequestMsg.Content = new StreamContent(context.Request.Body);

            #endregion



            #region see if there are headers that should not be passed to the server for this particular route
            var excludeHeaders = section.GetValue<string>("excluded_headers")?
                .Split(new char[] { ',', ' ', '\n', '\r' }, StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);

            if (excludeHeaders == null || excludeHeaders.Length < 1)
                // if no headers to exclude for this route, check if there are default headers to exclude for all routes
                excludeHeaders = _configuration.GetValue<string>("excluded_headers")?
                    .Split(new char[] { ',', ' ', '\n', '\r' }, StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);

            #endregion

            #region see if there are headers that should be overridden for this particular route

            var appliedHeaders = section.GetSection("applied_headers")?.GetChildren()?
                // remove null `name` headers
                .Where(x => !string.IsNullOrWhiteSpace(x.GetValue<string>("name")))
                .Select(x => new KeyValuePair<string, string>(x.GetValue<string>("name")!,
                x.GetValue<string>("value") ?? string.Empty))
                .ToDictionary(x => x.Key, x => x.Value);
            // adding the override headers to the target request
            if (appliedHeaders?.Count > 0 == true)
            {
                foreach (var header in appliedHeaders)
                {
                    _ = targetRequestMsg.Headers.TryAddWithoutValidation(header.Key, header.Value);
                }
            }

            #endregion


            #region get headers from the caller request and add them to the target request
            foreach (var header in context.Request.Headers)
            {

                if (
                    // exclude headers that should not be passed to the server (make sure to accomodate for case sensitivity)
                    excludeHeaders?.Contains(header.Key, StringComparer.OrdinalIgnoreCase) == true
                    || appliedHeaders?.Select(x => x.Key).Contains(header.Key, StringComparer.OrdinalIgnoreCase) == true
                    )
                    continue;
                _ = targetRequestMsg.Headers.TryAddWithoutValidation(header.Key, header.Value.ToArray());
            }
            #endregion


            try
            {
                #region check if the target route certificate errors should be ignored
                var ignoreCertificateErrors = section.GetValue<bool?>("ignore_target_route_certificate_errors");
                // if no ignore certificate errors for this route, check if there are default ignore certificate errors for all routes
                ignoreCertificateErrors ??= _configuration.GetValue<bool?>("default_ignore_target_route_certificate_errors");
                #endregion

                using (var client = ignoreCertificateErrors == true
                    ? httpClientFactory.CreateClient("ignoreCertificateErrors")
                    : httpClientFactory.CreateClient()
                    )

                {

                    var targetRouteResponse = await client.SendAsync(targetRequestMsg); // , HttpCompletionOption.ResponseHeadersRead);

                    context.Response.StatusCode = (int)targetRouteResponse.StatusCode;



                    #region setup the response headers back to the caller
                    // Copy response headers (general headers)
                    foreach (var header in targetRouteResponse.Headers
                        // Exclude Transfer-Encoding and Content-Length headers from being copied
                        // These headers must be managed by ASP.NET Core automatically:
                        // - Content-Length: Must reflect the actual response body size
                        // - Transfer-Encoding: Must align with how ASP.NET Core chunks the response
                        // Manually setting these headers would conflict with ASP.NET Core's 
                        // handling of the response stream and could cause corruption or errors
                        .Where(x => !excludedResponseHeaders.Contains(x.Key))
                        )
                    {
                        context.Response.Headers[header.Key] = header.Value.ToArray();
                    }

                    // Copy content headers (Content-Type, Content-Encoding, etc.)
                    // These are essential for proper content interpretation by the client
                    foreach (var header in targetRouteResponse.Content.Headers
                        .Where(x => !excludedResponseHeaders.Contains(x.Key))
                        )
                    {
                        context.Response.Headers[header.Key] = header.Value.ToArray();
                    }

                    #endregion


                    // copy the proxy call stream to the response stream
                    await targetRouteResponse.Content.CopyToAsync(
                        context.Response.BodyWriter.AsStream(),
                        // cancel the request if the client disconnects
                        // this is to prevent the server from sending the response body to the client
                        // after the client has disconnected
                        context.RequestAborted
                        );

                    // Complete the response stream.
                    // although this is not strictly necessary, 
                    // as the asp.net core is expected to close the stream when the response is disposed of,
                    // keeping this explicit call is a defensive programming approach that ensures proper
                    // completion regardless of how the framework's internals 
                    // might change in future versions.
                    context.Response.BodyWriter.Complete();
                }
            }
            catch (Exception ex)
            {
                await context.Response.DeferredWriteAsJsonAsync(_settings.GetExceptionResponse(context.Request, ex));
            }

        }
    }
}
