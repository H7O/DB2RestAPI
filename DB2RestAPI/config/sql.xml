<settings>
  <queries>

    <!-- Example API endpoint returning JSON -->
    <hello_world>
      <query>
        <![CDATA[
        
        declare @name nvarchar(500) = {{name}};


        if (@name is null or ltrim(rtrim(@name)) = '')
        begin
            set @name = 'world';
        end
        select 
        'hello ' + @name + '! Time now is ' + convert(nvarchar(50), getdate(), 121) as message_from_db;
        
        
        ]]>
      </query>
      <!--
      This is just an example of how you can define an API end-point that returns a JSON object.
      The query is a SQL query that returns a JSON object.
      The end-point path to this query is `/hello_world` (e.g., `http://localhost:5000/hello_world`).
      
      The example above shows how you can use parameters in your query. 
      The parameter `name` is passed in the query string or request body as JSON object.

      Precident of parameters if the same parameter is passed in multiple places is as follows (from highest to lowest):
      1. Request query string (if the parameter is passed in the query string, it will override any other parameter with the same name)
      2. Request route (if the parameter is passed in the route, it will override any other parameter with the same name)
      3. Request body (if the parameter is passed in the request body, it will override any other parameter with the same name)
      4. HTTP headers (if the parameter is passed in the HTTP headers, it is the least priority and will be used only if the parameter is not passed in the query string, route, or request body)
      
      all parameters are case-insensitive, so `name`, `Name`, and `NAME` are considered the same parameter.
      The default regex for parsing parameters (if not specified) is `(?<open_marker>\{\{)(?<param>.*?)?(?<close_marker>\}\})`
      
      Other examples in this sample sql.xml file should show you how to change the default regex for parsing each type of parameters.
      -->
    </hello_world>



    <!-- Contact creation endpoint -->
    <create_contact>
      <mandatory_parameters>name,phone</mandatory_parameters>
      <!-- 
      You can enforce mandatory parameters in your query by adding them in the `mandatory_parameters` node.
      Mandatory parameters are parameters that must be passed in the HTTP request.
      If any of the mandatory parameters are missing, the app will return an HTTP 400 error (bad request error).
      

      -->
      
      <!-- `<route>` node is optional, if you don't specify it, the query will be accessible by `create_contact` which is the name of the query node. -->
      <route>contacts</route>
      
      <verb>POST</verb>
      <!--  
      `<verb>` node is optional, if you don't specify it and you have only one unique route, the query will be accessible by any HTTP verb.
      if there are multiple routes with the same verb, the first one will be used.
      -->

      <!-- default value (if not specified) is `auto`, available options are `auto`, `single` and `array` -->
      <response_structure>single</response_structure>
      <!-- 
      `response_structure` is optional, if you don't specify it, the app defaults to `auto`.
       The possible values are:
       
      1- `array`: instructs the app to return an array of JSON objects for multiple rows response with the following rules:
        a) if the query returned a single row, that row is set to be returned as a json object inside an array
        b) if the query returned multiple rows, the app will return an array of JSON objects with the following structure:
          [
            {
              "id": 1,
              "name": "John",
              "phone": "1234567890"
            },
            {
              "id": 2,
              "name": "Jane",
              "phone": "0987654321"
            }
          ]
        
      2- `single`: instructs the app to return a single JSON object of the first row returned by the query and not iterate over the rest of the rows.
        however, if `count_query` node is specified, the app then is set to return a count structure as per the below structured
        response format but has only the first row returned by the query (i.e., not iterate over the rest of the rows)
      
      3- `auto`: for auto response format (single if single row, array if multiple rows)
      
      **Note**: if `count_query` is specified, the `response_structure` is then ignored as the app 
      is expected to always return a count structure as per the below structured response format:
          {
            "count": 1,
            "data": [
              {
                "id": 1,
                "name": "John",
                "phone": "1234567890"
              }
            ]
          }


      -->
      
      

      <!-- success_status_code is optional, if you don't specify it, the app will return 200 OK -->
      <success_status_code>201</success_status_code>

      <query>
      <![CDATA[
        declare @name nvarchar(500) = {{name}};
        declare @phone nvarchar(100) = {{phone}};
        declare @active bit = {{active}};
      
        -- check if the contact already exists
      
        declare @existing_contact table 
        (
            id UNIQUEIDENTIFIER,
            name nvarchar(500),
            phone nvarchar(100)
        );
        insert into @existing_contact select top 1 id, name, phone from [contacts] where name = @name and phone = @phone;
      
        declare @error_msg nvarchar(500);
      
        -- return an http 409 error (conflict error) if the contact already exists
      
        if ((select count(*) from [contacts] where name = @name and phone = @phone) > 0)
        begin 
            set @error_msg = 'Contact with name ' + @name + ' and phone ' + @phone + ' already exists';
            -- to return http error code `409 Conflict` throw 50409 and the app will return 409.
            -- same for other http error codes, e.g. 404, 500, etc. Just throw 50404, 50500, etc.
            throw 50409, @error_msg, 1;
            return;
        end
        if (@active is null)
        begin
            set @active = 1;
        end
      
      -- insert new contact, and return it back to the http client
      insert into [contacts] (id, name, phone, active) 
      output inserted.id, inserted.name, inserted.phone, inserted.active
      values (newid(), @name, @phone, @active)
    ]]>
      </query>

      
    </create_contact>




    <!-- Contact update endpoint -->
    <update_contact>
      <route>contacts/{{id}}</route>
      <verb>PUT</verb>
      
      <mandatory_parameters>id,name,phone</mandatory_parameters>

      <connection_string_name>server2</connection_string_name>
      <!-- 
      connection_string_name tag is optional, 
      the app is designed to pickup the `default` connection string you define in 
      /config/settings.xml under `ConnectionStrings` node if you haven't set one here.
      However, if you need to access a different database for a specific query,
      you can set a different connection string name here, given that you've defined it in /config/settings.xml
      under `ConnectionStrings` node.
      The below connection string name is added here just to show you how you can
      choose a different connection string name.
      -->


      <query>
      <![CDATA[

      -- update contact
      declare @id UNIQUEIDENTIFIER = {{id}};
      declare @name nvarchar(500) = {{name}};
      declare @phone nvarchar(100) = {{phone}};
      
      -- check if contact exists
      
      declare @error_msg nvarchar(500);
      
      -- return an http 404 error (not found error) if the contact does not exist
      
      if ((select count(*) from [contacts] where id = @id) < 1)
      begin 
          set @error_msg = 'Contact with id ' + cast(@id as nvarchar(50)) + ' does not exist';
          -- to return http error code `404 Not found` throw 50404 and the app will return 404.
          throw 50404, @error_msg, 1;
          return;
      end
      
      -- update the contact, and return it back to the http client

      update [contacts] 
      set 
            [name] = @name, 
            phone = @phone 
      output 
        inserted.id, 
        inserted.name, 
        inserted.phone
      where 
        id = @id;      
      
      ]]>
      </query>
    </update_contact>


    <!-- Contact activation/deactivation endpoint -->
    <activate_deactivate_contact>
      <connection_string_name>server2</connection_string_name>
      <route>contacts/{{id}}/{{status_action}}</route>
      <verb>PUT</verb>
      <mandatory_parameters>id</mandatory_parameters>
      
      <query>
      <![CDATA[

      -- update contact
      declare @id UNIQUEIDENTIFIER = {{id}};
      -- status_action can be either `activate` or `deactivate`
      declare @status_action nvarchar(50) = {{status_action}};

      declare @error_msg nvarchar(500);

      if (@status_action is null or @status_action = ''
      or @status_action not in ('activate', 'deactivate'))
      begin
        set @error_msg = 'Invalid status action';
        throw 50400, @error_msg, 1;
        return;
      end
        
      -- check if contact exists
      
      -- return an http 404 error (not found error) if the contact does not exist
      
      if ((select count(*) from [contacts] where id = @id) < 1)
      begin 
          set @error_msg = 'Contact with id ' + cast(@id as nvarchar(50)) + ' does not exist';
          -- to return http error code `404 Not found` throw 50404 and the app will return 404.
          throw 50404, @error_msg, 1;
          return;
      end
      
      -- update the contact, and return it back to the http client

      declare @status_bit bit = case when @status_action = 'activate' then 1 else 0 end;

      update [contacts] 
      set 
            [active] = @status_bit
      output 
        inserted.id, 
        inserted.name, 
        inserted.phone,
        case when inserted.active = 1 then 'active' else 'inactive' end as status
      where 
        id = @id;      
      ]]>
      </query>
    </activate_deactivate_contact>


    <!-- Contact search endpoint -->
    <search_contacts>
      <route>contacts</route>
      <verb>GET</verb>
      <query>
        <![CDATA[
        declare @name nvarchar(500) = {{name}};
        declare @phone nvarchar(100) = {{phone}};
        declare @take int = {{take}};
        declare @skip int = {{skip}};
        declare @sort_by nvarchar(50) = {{sort_by}};
        declare @sort_order nvarchar(10) = {{sort_order}};

        if (@sort_by is null or @sort_by = '')
        begin
            set @sort_by = 'name';
        end

        -- default take to 100 if not specified
        if (@take is null or @take < 1)
        begin
            set @take = 100;
        end
        -- make sure max take doesn't exceed 1000
        if (@take > 1000)
        begin
            set @take = 1000;
        end
        -- default skip to 0 if not specified
        if (@skip is null or @skip < 0)
        begin
            set @skip = 0;
        end
        
        -- validate and default sort parameters (no need for sort by `id` if `id` is GUID, unless your `id` is an incrumental number)
        -- you can also add by create date, update date, etc. but for the purpose of this example, we'll only sort by `name` and `phone`
        if (@sort_by is null or @sort_by not in ('name', 'phone'))
        begin
            set @sort_by = 'name';
        end
        
        if (@sort_order is null or @sort_order not in ('asc', 'desc'))
        begin
            set @sort_order = 'asc';
        end


      select * from [contacts] 
        where 
          (@name is null or [name] like '%' +  @name + '%')
          and (@phone is null or [phone] like '%' +  @phone + '%')
        order by 
          case when @sort_by = 'name' and @sort_order = 'asc' then [name] end asc,
          case when @sort_by = 'name' and @sort_order = 'desc' then [name] end desc,
          case when @sort_by = 'phone' and @sort_order = 'asc' then [phone] end asc,
          case when @sort_by = 'phone' and @sort_order = 'desc' then [phone] end desc
        offset @skip rows
        fetch next @take rows only;        
        
        ]]>
      </query>
      <count_query>
        <![CDATA[
        declare @name nvarchar(500) = {{name}};
        declare @phone nvarchar(100) = {{phone}};
        select count(*) from [contacts] 
        where 
          (@name is null or [name] like '%' +  @name + '%')
          and (@phone is null or [phone] like '%' +  @phone + '%');
        
        ]]>
      </count_query>
      <!-- 
      Count Query Configuration:
      count query is optional, if you don't specify it, 
      the app will not return the total count of the results 
      (total as in without pagination applied) 
      -->
    </search_contacts>


    <!-- Contact deletion endpoint -->
    <delete_contact>
      <route>contacts/{{id}}</route>
      <verb>DELETE</verb>
      <success_status_code>204</success_status_code>
      <mandatory_parameters>id</mandatory_parameters>
      <query>

        <![CDATA[
        declare @id UNIQUEIDENTIFIER = {{id}};
        -- check if contact exists
        declare @error_msg nvarchar(500);
        -- return an http 404 error (not found error) if the contact does not exist
        if ((select count(*) from [contacts] where id = @id) < 1)
        begin 
            set @error_msg = 'Contact with id ' + cast(@id as nvarchar(50)) + ' does not exist';
            -- to return http error code `404 Not found` throw 50404 and the app will return 404.
            throw 50404, @error_msg, 1;
            return;
        end
        -- delete the contact
        delete from [contacts] 
        OUTPUT DELETED.id, DELETED.name, DELETED.phone, DELETED.active
        where id = @id;
        
        ]]>
      </query>
    </delete_contact>



    <!-- Contact search without count endpoint -->
    <search_contacts_without_count>
      <route>contacts_without_count</route>
      <verb>GET</verb>

      <!-- default value (if not specified) is `auto`, available options are `auto`, `single` and `array` -->
      <response_structure>array</response_structure>
      <!-- 
      `response_structure` is optional, if you don't specify it, the app defaults to `auto`.
       The possible values are:
       
      1- `array`: instructs the app to return an array of JSON objects for multiple rows response with the following rules:
        a) if the query returned a single row, that row is set to be returned as a json object inside an array
        b) if the query returned multiple rows, the app will return an array of JSON objects with the following structure:
          [
            {
              "id": 1,
              "name": "John",
              "phone": "1234567890",
              "active": 1
            },
            {
              "id": 2,
              "name": "Jane",
              "phone": "0987654321",
              "active": 1
            }
          ]
        
      2- `single`: instructs the app to return a single JSON object of the first row returned by the query and not iterate over the rest of the rows.
        however, if `count_query` node is specified, the app then is set to return a count structure smiliar to the ones we saw in `search_contacts`query
      
      3- `auto`: for auto response format (single if single row, array if multiple rows)
      
      **Note**: if `count_query` is specified, the `response_structure` is then ignored as the app 
      is expected to always return a count structure as per the below structured response format:
          {
            "count": 2,
            "data": [
              {
                "id": 1,
                "name": "John",
                "phone": "1234567890",
                "active": 1
              },
              {
                "id": 2,
                "name": "Jane",
                "phone": "0987654321",
                "active": 1
              }
            ]
          }


      -->      
      
      
      
      <query>
        <![CDATA[
        declare @name nvarchar(500) = {{name}};
        declare @phone nvarchar(100) = {{phone}};
        declare @take int = {{take}};
        declare @skip int = {{skip}};
        declare @sort_by nvarchar(50) = {{sort_by}};
        declare @sort_order nvarchar(10) = {{sort_order}};

        if (@sort_by is null or @sort_by = '')
        begin
            set @sort_by = 'name';
        end

        -- default take to 100 if not specified
        if (@take is null or @take < 1)
        begin
            set @take = 100;
        end
        -- make sure max take doesn't exceed 1000
        if (@take > 1000)
        begin
            set @take = 1000;
        end
        -- default skip to 0 if not specified
        if (@skip is null or @skip < 0)
        begin
            set @skip = 0;
        end
        
        -- validate and default sort parameters (no need for sort by `id` if `id` is GUID, unless your `id` is an incrumental number)
        -- you can also add by create date, update date, etc. but for the purpose of this example, we'll only sort by `name` and `phone`
        if (@sort_by is null or @sort_by not in ('name', 'phone'))
        begin
            set @sort_by = 'name';
        end
        
        if (@sort_order is null or @sort_order not in ('asc', 'desc'))
        begin
            set @sort_order = 'asc';
        end


      select * from [contacts] 
        where 
          (@name is null or [name] like '%' +  @name + '%')
          and (@phone is null or [phone] like '%' +  @phone + '%')
        order by 
          case when @sort_by = 'name' and @sort_order = 'asc' then [name] end asc,
          case when @sort_by = 'name' and @sort_order = 'desc' then [name] end desc,
          case when @sort_by = 'phone' and @sort_order = 'asc' then [phone] end asc,
          case when @sort_by = 'phone' and @sort_order = 'desc' then [phone] end desc
        offset @skip rows
        fetch next @take rows only;        
        
        ]]>
      </query>

    </search_contacts_without_count>    
    
    
    


    <!-- Protected endpoint with local API keys (for global keys, use global_api_keys.xml) -->
    <protected_hello_world>
      <api_keys>
        <key>api key 1</key>
        <key>api key 2</key>
      </api_keys>
      <!-- 
      API Key Configuration:
      you can define per query api keys, 
      if you don't specify it, the query will be publically accessible unless you define global api keys in /config/global_api_keys.xml
      -->
      <query>
        <![CDATA[
        declare @name nvarchar(500) = {{name}};
        
        if (@name is null or ltrim(rtrim(@name)) = '')
        begin
            set @name = 'world';
        end
        select 'hello ' + @name + '!' as message_from_db;
        ]]>
      </query>
    </protected_hello_world>


    <!-- Custom variable delimiters example -->
    <hello_world_using_pipes_as_var_delimiters>
      <json_variables_regex><![CDATA[(?<open_marker>\|\|)(?<param>.*?)?(?<close_marker>\|\|)]]></json_variables_regex>
      <!-- 
      Variable Delimiter Configuration:
      this is to showcase how you can override the default 
      variable delimiters regex for each query
      -->
      <query>
        <![CDATA[
        declare @name nvarchar(500) = ||name||;
        
        if (@name is null or @name = '')
        begin
            set @name = 'world';
        end
        select 'hello ' + @name + '!' as message_from_db;
        ]]>
      </query>
    </hello_world_using_pipes_as_var_delimiters>



    <!-- Caching example -->
    <hello_world_with_cache>
      <cache>
        <memory>
          <duration_in_milliseconds>20000</duration_in_milliseconds>
          <invalidators>name</invalidators>
        </memory>
      </cache>
      <query>
        <![CDATA[
        
        declare @name nvarchar(500) = {{name}};


        if (@name is null or ltrim(rtrim(@name)) = '')
        begin
            set @name = 'world';
        end
        select 'hello ' + @name + '! Time now is ' + convert(nvarchar(50), getdate(), 121) as message_from_db;
        
        
        ]]>
      </query>


    </hello_world_with_cache>


    <!-- Nested JSON example -->
    <nested_json>
      <query>
        <![CDATA[
              SELECT
                  name,
                  (
                      SELECT phone
                      FROM contacts c2
                      WHERE c2.name = c1.name AND c2.active = 1
                      FOR JSON PATH
                  ) AS {type{json{phones}}},
                  1 AS active
              FROM contacts c1
              WHERE c1.active = 1
              GROUP BY name;        
        ]]>
      </query>
      <!--
      JSON Type Decorator:
      The {type{json{field_name}}} decorator tells the engine to parse the returned JSON string 
      and embed it as a proper nested JSON object instead of an escaped string.
      
      WITHOUT `{type{json{phones}}}` decorator, the returned result would look like this:
      
      ```json
      [
          {
              "name": "Bob Johnson",
              "phones": "[{\"phone\":\"+1-555-0103\"},{\"phone\":\"+1-555-0103\"}]",
              "active": 1
          },
          {
              "name": "Jane Smith",
              "phones": "[{\"phone\":\"+1-555-0102\"},{\"phone\":\"+1-555-0102\"}]",
              "active": 1
          },
          {
              "name": "John Doe",
              "phones": "[{\"phone\":\"+1-555-0101\"},{\"phone\":\"+1-555-0101\"}]",
              "active": 1
          }
      ]      
      ```

      WITH `{type{json{phones}}}` decorator, the returned result would look like this:

      ```json
      [
          {
              "name": "Bob Johnson",
              "phones": [
                  {
                      "phone": "+1-555-0103"
                  },
                  {
                      "phone": "+1-555-0103"
                  }
              ],
              "active": 1
          },
          {
              "name": "Jane Smith",
              "phones": [
                  {
                      "phone": "+1-555-0102"
                  },
                  {
                      "phone": "+1-555-0102"
                  }
              ],
              "active": 1
          },
          {
              "name": "John Doe",
              "phones": [
                  {
                      "phone": "+1-555-0101"
                  },
                  {
                      "phone": "+1-555-0101"
                  }
              ],
              "active": 1
          }
      ]      
      ```
      
      This makes your API responses much cleaner and eliminates the need for 
      additional JSON.parse() calls on the client side.
      -->
    </nested_json>

    <file_upload_example>
      <route>upload_file</route>
      <verb>POST</verb>
      <document_management>
        <!-- file stores could be a local store or an sftp remote store, their individual
        settings correspondes to the ones defined in your settings.xml file under 
        `document_management` -> `file_stores` node
         -->
        <file_stores>location1, myfiles, site2</file_stores>


        <!-- `permitted_file_extensions` is optional, if not defined, 
        if will first check if there is a `permitted_file_extensions` tag defined
        for each of the `file_stores` defined in your settings.xml, 
        if not it will allow all file types -->
        <permitted_file_extensions>.txt,.pdf,.docx,.xlsx,.png,.jpg,.jpeg</permitted_file_extensions>

        <!-- `max_file_size_in_bytes` is optional, if not defined,
        it will first check if there is a `max_file_size_in_bytes` tag defined
        for each of the `file_stores` defined in your settings.xml,
        if not it will default to 10 MB -->
        <max_file_size_in_bytes>10485760</max_file_size_in_bytes> <!-- 10 MB -->

        <!-- the below two field would fallback on `file_store` settings if not defined here -->
        <filename_field_in_payload>name</filename_field_in_payload>
        <base64_content_field_in_payload>content_base64</base64_content_field_in_payload>


        <pass_files_content_to_query>false</pass_files_content_to_query>
        <!-- `pass_files_content_to_query` controls whether the uploaded files content is passed to the SQL query
        when set to true, the files content will be included in the query.
        when set to false, only the files metadata will be passed to the query.
        if not defined, the app will check if it's defined in settings.xml under `document_management` node,
        if not, it will default to false.
        
        
        
        The structure to be passed to the query as follows in json:
        
        ```json
        [
            {
              "id": "generated GUID for the file by the engine, unless passed by the caller",
              "name": "example.txt",
              "relative_path": "2025/Oct/22/<some-guid-goes-here>/example.txt",
              "extension": ".txt",
              "size": 1234,
              "content_base64": "SGVsbG8gd29ybGQh..."
            },
            ...
        ]
        ```
        
        `content_base64` field will only be included if `pass_files_content_to_query` is set to true.
        
        `id` is a GUID generated by the engine for each uploaded file, unless the caller provides it during upload.
        `relative_path` is the base path of the file store + `document_management:relative_file_path_structure`
          e.g., if the base path is `c:\filestore` and the `relative_file_path_structure` is `{date{yyyy}}\{date{MMM}}\{date{dd}}\{{guid}}\{file{name}}`
          then the full path of the file will be `c:\filestore\2025\Oct\22\<some-guid-goes-here>\example.txt`
        
        the caller can enrich the file metadata during upload by providing additional fields such as `description` (or any other custom fields)
        
        To do so, the caller needs to pass json metadata for each file being uploaded as follows:
        
        ```json
        [
            {
              "id": "optional GUID for the file, if not provided, the engine will generate one",
              "name": "example.txt",
              "description": "This is an example text file",
              // other custom fields can be added here
            },
            ...
        ]
        ```
        
        The caller can send the files and its metadata in either `application/json` or `multipart/form-data` content type.
        
        1- For `application/json` content type, the caller needs to send a json payload having both the metadata and content 
        in a json property of their choosing:
        e.g., if the caller chooses to send the files in a json property named `files`,
        
        ```json
        {
            "name": "John",
            "age": 30,
                // other json payload fields can go here
            "files": [
                {
                  "id": "optional GUID for the file, if not provided, the engine will generate one",
                  "name": "example.txt",
                  "description": "This is an example text file",
                  "content_base64": "SGVsbG8gd29ybGQh..."
                  // other custom fields can be added here
                },
                ...
            ]
        }
        ```
        
        Only the `name` and `content_base64` fields are mandatory for each file being uploaded.
        
        Receiving the metadata (and the base64 content if that option is enabled) in sql query in this case can be done via `{files{json_metadata_field_name}}`
        which in our example is `{files{files}}`
        
        
        2- For `multipart/form-data` content type, the caller can upload files in any way they like, 
          and choose a form field to send the files metadata in as a json payload.
          for example, if the caller chooses to send the files metadata in a form field named `metadata`
          the sql query can access the files metadata (along with base64 content if that option is enabled)  via `{files{metadata}}`
        
        -->

        <max_number_of_files>5</max_number_of_files>
        <!-- max_number_of_files is optional, if not defined, it will check if it's defined in the file store settings,
        if not, it will default to 10 files per request
          -->
      </document_management>
      <query>
        <![CDATA[
          -- you can use `{files{metadata_field_name}}` to access the uploaded files metadata and content
          -- depending on the `document_management` -> `pass_files_content_to_query`
          -- the file content will be included or not

          declare @files_json nvarchar(max) = {files{metadata_field_name}};
          -- you can parse the json and insert the file metadata into your database as needed
          

        ]]>
      </query>

    </file_upload_example>

    <test_json>
      <query>
        <![CDATA[
        declare @json_data nvarchar(max) = {{json_data}};
          select 'john' as name,
          @json_data as {type{json{received_json_data}}};
        ]]>
      </query>
    </test_json>
    <test_json2>
      <query>
        <![CDATA[
          SELECT 
            'John' as [name],
            (select * from (values 
		        ('55555', 'Mobile'), 
		        ('44444', 'Work')) 
          as t (number, [type]) for json path) AS {type{json{phones}}};
        ]]>
      </query>
    </test_json2>

  </queries>

</settings>