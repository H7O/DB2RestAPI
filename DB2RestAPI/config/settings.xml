<settings>

  <ConnectionStrings>
    <default><![CDATA[Data Source=.\s22;Initial Catalog=test;Integrated Security=True;TrustServerCertificate=True;]]></default>

    <!--
    This is just an example of how you can define a different connection string name for a different database server.
    You can define as many connection string names as you want that points to different database servers.
    -->
    <server2><![CDATA[Data Source=.\s22;Initial Catalog=test;Integrated Security=True;TrustServerCertificate=True;]]></server2>
  </ConnectionStrings>

  <additional_configurations>
    <path>config/sql.xml</path>
    <path>config/api_gateway.xml</path>
    <path>config/global_api_keys.xml</path>
    
    <!-- 
    Controls whether the application automatically restarts when configuration file paths are added or removed.
    - true: Application will automatically stop (allowing IIS/hosting environment to restart it)
    - false (default): Logs a warning, requires manual application pool recycle to apply path changes
    Note: Content changes within existing configuration files always reload automatically.
    -->
    <restart_on_path_changes>false</restart_on_path_changes>
  </additional_configurations>


  <!-- 
  if 'true', the system will look for HTTP header 'x-api-key' for the key and try to find if it's available in config/api_keys.xml 
  alternatively, you can skip this process if either you don't need to use API keys, 
  you'd like to use local API keys in `sql.xml` or `routes.xml`, 
  or you'd prefer to pass the API key to your query in sql.xml and implement your own check in SQL instead
  -->
  <enable_global_api_keys>false</enable_global_api_keys>
  
  <!-- the default regex that detects json payload variable delimiters in sql queries
  is `(?<open_marker>\{\{)(?<param>.*?)?(?<close_marker>\}\})` 
  even if you delete the `default_variables_regex` node, 
  the system will use the default regex above.
  You can also change it to something else if you want to, 
  for example, if you want to have the variable delimiters to be
  double pipes `||`, you can use the following regex
  `(?<open_marker>\|\|)(?<param>.*?)?(?<close_marker>\|\|)`.
  Also, you can override the default regex for each query in sql.xml
  by just simply adding the `variables_regex` attribute to the `query` node
  -->
  <default_variables_regex><![CDATA[(?<open_marker>\{\{)(?<param>.*?)?(?<close_marker>\}\})]]></default_variables_regex>


  <!-- the default regex that detects query string variables (e.g., the `?name=John&phone=123` in `https://example.com/your_api_call?name=John&phone=123` ) in sql queries
  is `(?<open_marker>\{qs\{)(?<param>.*?)?(?<close_marker>\}\})`
  even if you delete the `default_query_string_variables_regex` node,
  the system will use the default regex above.
  You can override the default regex for each query in sql.xml
  by just simply adding the `query_string_variables_regex` attribute to the `query` node
  -->
  <default_query_string_variables_regex><![CDATA[(?<open_marker>\{\{)(?<param>.*?)?(?<close_marker>\}\})]]></default_query_string_variables_regex>

  <!-- the default regex that detects header variables (e.g., the `x-api-key` in HTTP headers) in sql queries
  is `(?<open_marker>\{header\{)(?<param>.*?)?(?<close_marker>\}\})`
  even if you delete the `default_headers_variables_regex` node,
  the system will use the default regex above.
  You can override the default regex for each query in sql.xml
  by just simply adding the `headers_variables_regex` attribute to the `query` node
  -->
  <default_headers_variables_regex>
    <![CDATA[(?<open_marker>\{header\{)(?<param>.*?)?(?<close_marker>\}\})]]>
  </default_headers_variables_regex>

  <!--
  NOTE: if you use the same regex for two (or more) types of variables,
  and you pass the same variable in two (or more) types of variables,
  the system will prioritize the variable to use in the following order:
  1. payload variables
  2. query string variables
  3. header variables
  
  So based on the above order, if you pass `name` in both payload and query string variables 
  (e.g., in query string you have `?name=John1` and in json payload you have `{ "name" : "John2" }`),
  and you have the regex for both payload and query string being the same,
  the system will use the value of `name` in payload variables, i.e., `John2`.
  
  -->
  
  <!-- passing the value in the below `debug_mode_header_value` 
  as a value to header `debug-mode` in your HTTP request will enable debug mode
  allowing you to see the SQL query errors returned by the database server
  in your HTTP response.
  -->
  <debug_mode_header_value>54321</debug_mode_header_value>
  
  <default_generic_error_message><![CDATA[An error occurred while processing your request.]]></default_generic_error_message>

  <!-- Default headers to ignore when routing API Gateway requests 
  (e.g., when you have a route in `api_gateway.xml` that routes requests to another API)
  This is important to strip headers like `Host` when routing requests to another API
  as it may cause issues with the target API TLS certificate validation.
  Or you may want to strip `x-api-key` header when routing requests to another API
  when the `x-api-key` is processed locally by this application and not needed by the target API.
  This value can be overridden in each route in `api_gateway.xml` by adding the `headers_to_exclude_from_routing` attribute to the `route` node
  -->
  <default_headers_to_exclude_from_routing>Host</default_headers_to_exclude_from_routing>

  <!--
  If 'true', the system will ignore certificate errors when routing requests to another API
  (e.g., when you have a route in `api_gateway.xml` that routes requests to another API)
  This is useful when the target API has a self-signed certificate or an expired certificate.
  This value can be overridden in each route in `api_gateway.xml` by adding the `ignore_certificate_errors` attribute to the `route` node
  -->
  <ignore_certificate_errors_when_routing>false</ignore_certificate_errors_when_routing>

  <!--
  Allows for passing a timeout value in seconds for the DB command execution
  -->
  <default_db_command_timeout>30</default_db_command_timeout>
  
  <!-- 
  `default_cache` can be specified here with similar structure to  `cache` structure on API nodes 
  and it will be applied to all APIs unless overridden at the API level.
  -->


  <document_management>
    <relative_file_path_structure>{date{yyyy}}\{date{MMM}}\{date{dd}}\{{guid}}\{file{name}}</relative_file_path_structure>
    <!--
      The variables you can use in the relative file path structure are:
        {date{yyyy}} - year in 4 digits
        {date{MMM}} - month in 3 letters
        {date{dd}} - day in 2 digits
        Note: you can change the date formats as you want by using standard .NET date format patterns
        {guid} - a new GUID
        {file{name}} - the original file name uploaded by the client

        The file structure above to be appended to the local path defined in each local file store node below
        or the remote path defined in each sftp file store node below
    -->

    <permitted_file_extensions>.txt,.pdf,.docx,.xlsx,.png,.jpg,.jpeg</permitted_file_extensions>
    <!-- this is the default permitted file extensions, and can be overriden 
          per API node in sql.xml
          if not defined, all file extensions will be permitted
          override precedence is: API node > global setting here
          -->

    <max_number_of_files>5</max_number_of_files>
    <!-- max_number_of_files is optional, if not defined, 
    it will default to 10 files per request, can be overridden 
    per API node in sql.xml
    override precedence is: API node > global setting here
      -->
    <files_json_field_or_form_field_name>files</files_json_field_or_form_field_name>
    <!-- files_json_field_or_form_field_name is optional, if not defined, 
    it will default to `files`, can be overridden
    per API node in sql.xml
    override precedence is: API node > global setting here
    -->
    <json_payload_form_field_name>json</json_payload_form_field_name>
    <!-- json_payload_form_field_name is optional, if not defined, 
    it will default to `json`, can be overridden
    per API node in sql.xml
    override precedence is: API node > global setting here
    -->

    <max_file_size_in_bytes>10485760</max_file_size_in_bytes> <!-- 10 MB -->
    <!-- this is the default max file size in bytes, and can be overriden 
          per API node in sql.xml
          if not defined, default is 10 MB
          override precedence is: API node > global setting here
          -->


    <!-- you can define as much as you want local file stores or sftp stores and just reference their names 
      in your API node in sql.xml under `<file_stores>location1, myfiles, site4, etc..</file_stores>`
      You can give these locations any names you want (e.g., location1, siteA, myFiles, etc..)
    -->
    <local_file_store>
      <location1>
        <local_path><![CDATA[c:\location1\]]></local_path>
      </location1>
      <myfiles>
        <local_path><![CDATA[c:\myfiles\]]></local_path>
      </myfiles>
      <site4>
        <local_path><![CDATA[c:\site4\]]></local_path>
        <!-- if optional is set to `true`, it means if the file failed to be copied to this location (for any reason), 
        it will be ignored and the process will continue without failing the entire request.
        default is `false` if tag is not present
        -->
        <optional>true</optional>

      </site4>
    </local_file_store>

    <sftp_file_store>
      <site1>
        <host><![CDATA[192.168.1.100]]></host>
        <port>22</port>
        <username><![CDATA[test]]></username>
        <password><![CDATA[password123]]></password>
        <remote_path><![CDATA[/site1/]]></remote_path>
        <enabled><![CDATA[true]]></enabled>
      </site1>
      <site2>
        <host><![CDATA[192.168.2.200]]></host>
        <port>22</port>
        <username><![CDATA[test]]></username>
        <password><![CDATA[password123]]></password>
        <remote_path><![CDATA[/site2/]]></remote_path>
        <enabled><![CDATA[true]]></enabled>
        <!-- if optional is set to `true`, it means if the file failed to be copied to this location (for any reason), 
        it will be ignored and the process will continue without failing the entire request
        default is `false` if tag is not present
        -->
        <optional>true</optional>


      </site2>

    </sftp_file_store>

  </document_management>

</settings>