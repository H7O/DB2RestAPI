# Database-to-Rest API

This is a sample solution that shows how to create a REST API from a database with DB-first approach.

All you need to have is knowledge in writing SQL queries and you'll hopefully be on your way building safe and secure REST APIs in minutes.

You can expand on this solution to add more features like authentication, authorization, logging, etc..

However, for public APIs or B2B APIs with API keys, you can use this solution as is. You'll be surprised how easy it is to build a REST API from a database using this approach.

## How to use

1. Create a sample database and name it `test`, then run the SQL script below to create a sample `phone_book` table within the `test` database that you just created.

> **Note**: Download and install either SQL Server Developer Edition or SQL Server Express if you don't have SQL Server installed on your machine

```sql
CREATE TABLE [dbo].[phone_book] (
    [id]    UNIQUEIDENTIFIER CONSTRAINT [DEFAULT_phone_book_id] DEFAULT (newid()) NOT NULL,
    [name]  NVARCHAR (500)   NULL,
    [phone] NVARCHAR (100)   NULL,
    CONSTRAINT [PK_phone_book] PRIMARY KEY CLUSTERED ([id] ASC)
);
```

2. Clone (or download) this repository.
3. Open the solution in Visual Studio.
4. Open the `/config/settings.xml` file and change the default `ConnectionStrings` to point to your `test` database.
5. Run the solution.
6. Download and install [Postman](https://www.postman.com/downloads/).
7. Open Postman and create a new request.
8. Set the request method to `POST` (or `GET`).
9. Set the request URL to `https://localhost:<your_custom_port>/hello_world`.
10. Fill `Content-Type` header with `application/json`.
11. Fill the request body with the following JSON:

```json
{
	"name": "John",
}
```
12. Send the request and you should see the following JDON respons: 
```json

[
    {
        "message_from_db": "hello John!"
    }
]
```
13. To see how the API works, change the `name` property in the request body to `Jane` and send the request again. You should see a different response from the database.
14. To see the SQL query that generated the response, open the `/config/sql.xml` file and look for the `hello_world` query. You can change the query to anything you want and the API will still work as long as the query is valid and returns at least a single row.
15. If you examine the `hello_world` query in `/config/sql.xml`, you'll find the use of the `{{name}}` parameter. This parameter is passed from the request body to the query. You can add as many parameters as you want and use them in your queries.
```sql
declare @name nvarchar(500) = {{name}};
        
if (@name is null or @name = '')
begin
    set @name = 'world';
end
select 'hello ' + @name + '!' as message_from_db;
```
> **Note**: Passing parameters is safe and secure. The solution is designed to protect against SQL injection attacks by default via utilizing SQL Server's built-in parameterization feature. 
> The SQL parameterization feature is offered by `Com.H.Data.Common` package (available on [Github](https://github.com/H7O/Com.H.Data.Common) / [Nuget](https://www.nuget.org/packages/Com.H.Data.Common/)).


## Phonebook API examples

### Example 1 - Adding a phone book record

Now, let's try to create a new record in the `phone_book` table. 
1. To do that, change the request URL to `https://localhost:<your_custom_port>/add_contact` and change the request method to `POST`.
2. Fill `Content-Type` header with `application/json`.
3. Fill the request body with the following JSON: 
```json
{
	"name": "John",
	"phone": "1234567890"
}
```
4. Send the request and you should see the following JDON respons: 
```json
[
	{
		"id": "b0b0b0b0-b0b0-b0b0-b0b0-b0b0b0b0b0b0",
		"name": "John",
		"phone": "1234567890"
	}
]
```
> **Note**: The `id` property is generated by the database and returned by the API. You can use this `id` to update or delete the record later.
> The `id` property is a `GUID` and is generated by the database by default. You can change the `id` property to be an `int` or `bigint` and set it to `IDENTITY` to be auto-incremented by the database.
> The `id` property in the sample response above is just a sample value and not the actual value that you'll get from the API.
5. To see how the API works, change the `name` and `phone` properties in the request body and send the request again. You should see a different response from the database.
6. Try adding multiple records with different names and phone numbers.
8. Try also adding the same name and phone number multiple times. 
You should get an error message from the database saying that the record already exists.
How this error is thrown from the database is up to you. 
The following XML tag in `/config/sql.xml` for `add_contact` illustrates how to throw an error from the database:
```xml
    <add_contact>
      <!--
      You can enforce mandatory parameters in your query by adding them in the `mandatory_parameters` node.
      Mandatory parameters are parameters that must be passed in the HTTP request.
      If any of the mandatory parameters are missing, the app will return an HTTP 400 error (bad request error).
      -->
      <mandatory_parameters>name,phone</mandatory_parameters>
      <query>
      <![CDATA[
        declare @name nvarchar(500) = {{name}};
        declare @phone nvarchar(100) = {{phone}};
      
        -- check if the contact already exists
      
        declare @existing_contact table 
        (
            id UNIQUEIDENTIFIER,
            name nvarchar(500),
            phone nvarchar(100)
        );
        insert into @existing_contact select top 1 id, name, phone from [phone_book] where name = @name and phone = @phone;
      
        declare @error_msg nvarchar(500);
      
        -- return an http 409 error (conflict error) if the contact already exists
      
        if ((select count(*) from [phone_book] where name = @name and phone = @phone) > 0)
        begin 
            set @error_msg = 'Contact with name ' + @name + ' and phone ' + @phone + ' already exists';
            -- to return http error code `409 Conflict` throw 50409 and the app will return 409.
            -- same for other http error codes, e.g. 404, 500, etc. Just throw 50404, 50500, etc.
            throw 50409, @error_msg, 1;
            return;
        end
      
      -- insert new contact, and return it back to the http client
      insert into [phone_book] (id, name, phone) 
      output inserted.id, inserted.name, inserted.phone
      values (newid(), @name, @phone)
      

    ]]>
      </query>
      
    </add_contact>
```
Notice how throwing any error with code number between 50000 and 51000 will be caught by the app and returned to the client as an HTTP error code between 0 and 1000.

For example, throwing error code 50409 will be returned to the client as HTTP error code 409 along with the message that you passed to the `throw` statement.

So basically, the reserved error code range 50000-51000 is mapped to the HTTP error code range 0-1000.

Anything outside the reserved error code range 50000-51000 will be returned to the client as HTTP error code 500 with a generic error message of `An error occurred while processing your request.`.

This is a safety measure to prevent exposing any sensitive information from the database to the client.

The default error message content can be changed in the `/config/settings.xml` file by changing the `default_generic_error_message` node.

### Example 2 - Updating a phone book record

Now, let's try to update a record in the `phone_book` table.
1. To do that, change the request URL to `https://localhost:<your_custom_port>/update_contact` and change the request method to `POST`.
2. Fill `Content-Type` header with `application/json`.
3. Fill the request body with the following JSON: 
```json
{
	"id": "b0b0b0b0-b0b0-b0b0-b0b0-b0b0b0b0b0b0",
	"name": "John Update 1",
	"phone": "1234567890"
}
```
4. Send the request and you should see the following JDON respons: 
```json
[
	{
		"id": "b0b0b0b0-b0b0-b0b0-b0b0-b0b0b0b0b0b0",
		"name": "John Update 1",
		"phone": "1234567890"
	}
]
```
The response above shows the updated record.

5. To see how the API works, change the `name` and/or `phone` properties in the request body and send the request again. You should see a different response from the database.
6. Try updating the same record multiple times.
7. Try also updating a record that doesn't exist.
You should get an error message from the database saying that the record doesn't exist.
The error will be returned to the client as HTTP error code 404 (not found error).

### Example 3 - Retrieving phone book records

Now, let's try to retrieve records from the `phone_book` table.
1. To do that, change the request URL to `https://localhost:<your_custom_port>/get_contact` and change the request method to `POST`.
2. Fill `Content-Type` header with `application/json`.
3. Fill the request body with the following JSON: 
```json
{
	"name": "j"
}
```
The `name` property is a search parameter. The API will return all records that contain the `name` value in the `name` column. The search is case-insensitive.

You can also use the `phone` property as a search parameter. The API will return all records that contain the `phone` value in the `phone` column. The search is case-insensitive.

You can also use both `name` and `phone` properties as search parameters. The API will return all records that contain the `name` value in the `name` column and the `phone` value in the `phone` column. The search is case-insensitive.

Check the `/config/sql.xml` file for the `get_contact` query to see how the search parameters are used in the query.

4. Try passing `take` and `skip` parameters in the request body to limit the number of records returned and to skip a number of records.
```json
{
	"name": "j",
	"take": 10,
	"skip": 0
}
```

This helps in implementing pagination in your API. Check the `/config/sql.xml` file for the `get_contact` query to see how the `take` and `skip` parameters are used in the query.

### Example 4 - Deleting a phone book record

Now, let's try to delete a record in the `phone_book` table.
1. To do that, change the request URL to `https://localhost:<your_custom_port>/delete_contact` and change the request method to `POST`.
2. Fill `Content-Type` header with `application/json`.
3. Fill the request body with the following JSON: 
```json
{
	"id": "b0b0b0b0-b0b0-b0b0-b0b0-b0b0b0b0b0b0"
}
```
> **Note**: The above is an example `id` value. You can use any `id` value that you get from the API when you add a new record or retrieve records.

4. Send the request and you should see the following JDON respons: 
```json
[
	{
		"id": "b0b0b0b0-b0b0-b0b0-b0b0-b0b0b0b0b0b0",
		"name": "John Update 1",
		"phone": "1234567890"
	}
]
```
> **Note**: The above is an example response. You'll get the same response when you update a record but with different values. The response is just to show you the record that was deleted.

If the record doesn't exist, you'll get an error message from the database saying that the record doesn't exist.
The error will be returned to the client as HTTP error code 404 (not found error).


**documentation in progress - more examples to be added soon**